<!DOCTYPE html>
<html lang="en">
<head>
<title>Typing game</title>
</head>

<style>
    
</style>

<body onload="onLoad()">
    <div id="MainMenu" style="display: flex; flex-direction: column; align-items: center; row-gap: 30px;">
        <button id="CreateRoomButton" style="width: 50%;">Create Room</button>
        <span>Enter room key: <input id="JoinRoomTextbox" type="text"></input></span>
    </div>
    <span id="RoomKeySpan" style="display: none;">room key: <span id="RoomKeyValueSpan"></span></span><br/>
    <span style="font-size: 20px;">Health: <span id="HealthSpan" style="color: red;">100</span></span>
    <attack-window id="AttackWindow" style="left: 50%; top: 50%; position: absolute; display: none;"></attack-window>
    <defense-window id="DefenseWindow" style="left: 50%; top: 50%; position: absolute; display: none;"></defense-window>
</body>

<script type="text/javascript">
    let socket = null;
    // ON LOAD FUNCTION.    
    onload = () =>
    {
        // HANDLE THE USER CREATING A ROOM.
        const createRoomButton =  document.getElementById("CreateRoomButton");
        createRoomButton.addEventListener("click", () =>
        {
            const createRoomUrl = new URL("/createRoom", window.location.href);
            socket = new WebSocket(createRoomUrl.href);
            socket.onclose = () =>
            {
                console.log("websocket closed.");
            };
            startGame(socket).then((reason) =>
            {
                console.log(reason)
                // GO BACK TO THE MAIN MENU.
                const attackWindow = document.getElementById("AttackWindow").Close();
                const defenseWindow = document.getElementById("DefenseWindow").Close();
                const mainMenu = document.getElementById("MainMenu");
                mainMenu.style.display = "flex";
            });
        });

        // HANDLE THE USER JOINING A ROOM.
        const joinRoomTextbox =  document.getElementById("JoinRoomTextbox");
        joinRoomTextbox.addEventListener("keypress", (event) =>
        {
            if (event.key == "Enter")
            {
                const joinRoomUrl = new URL("/joinRoom", window.location.href);
                joinRoomUrl.searchParams.append("roomKey", joinRoomTextbox.value.trim());
                socket = new WebSocket(joinRoomUrl.href);
                socket.onclose = () =>
                {
                    console.log("websocket closed.");
                };
                startGame(socket).then((reason) =>
                {
                    console.log(reason)
                    // GO BACK TO THE MAIN MENU.
                    const attackWindow = document.getElementById("AttackWindow").Close();
                    const defenseWindow = document.getElementById("DefenseWindow").Close();
                    const mainMenu = document.getElementById("MainMenu");
                    mainMenu.style.display = "flex";
                });
            } 
        });
    }

    startGame = async (socket) =>
    {
        // HIDE THE MAIN MENU.
        const mainMenu = document.getElementById("MainMenu");
        mainMenu.style.display = "none";

        // HANDLE THE SOCKET DISCONNECTING.
        let gameEndPromiseResolver;
        socket.onclose = () => { gameEndPromiseResolver("The connection was closed by the server."); };
        socket.onerror = () => { gameEndPromiseResolver("The connection was closed due to a connection error."); };

        // HANDLE MESSAGES FROM THE WEBSOCKET CONNECTION.
        const attackWindow = document.getElementById("AttackWindow");
        const defenseWindow = document.getElementById("DefenseWindow");
        socket.onmessage = (event) =>
        {
            const message = JSON.parse(event.data);
            switch (message.type)
            {
                case "created":
                {
                    // Show the room key.
                    const roomKeySpan = document.getElementById("RoomKeySpan");
                    roomKeySpan.style.display = "block";
                    const roomKeyValueSpan = document.getElementById("RoomKeyValueSpan");
                    roomKeyValueSpan.innerText = message.roomKey;
                    break;
                }
                case "start":
                {
                    // Hide the room key.
                    const roomKeySpan = document.getElementById("RoomKeySpan");
                    roomKeySpan.style.display = "none";

                    // Reset the health.
                    const healthSpan = document.getElementById("HealthSpan");
                    healthSpan.innerText = 100;

                    break;
                }
                case "attack":
                {
                    attackWindow.Open().then((res) =>
                    {
                        attackWindow.Close();
                        socket.send(JSON.stringify(res));
                    });
                    break;
                }
                case "defend":
                {
                    defenseWindow.Open(message.phrase).then((res) =>
                    {
                        defenseWindow.Close();
                        socket.send(JSON.stringify(res));
                    });
                    break;
                }
                case "result":
                {
                    // Update the health.
                    const healthSpan = document.getElementById("HealthSpan");
                    healthSpan.innerText = message.health;

                    // Display the message.
                    console.log(message.resultMessage);
                    break;
                }
                default:
                    gameEndPromiseResolver("Game ended due to unknown reason.");
                    break;
            }
        }

        // CREATE THE PROMISE TO BE RESOLVED WHEN THE GAME ENDS.
        return new Promise((resolve) =>
        {
            gameEndPromiseResolver = resolve;
        });
    }

    // THE TIMER CONTROL.
    class GameTimer extends HTMLElement
    {
        // ELEMENTS.
        #timerSpan = null;

        // PRIVATE MEMBERS.
        #timeLeftInTimer = 0;
        #timerIntervalId = null;
        #timerPromiseResolver;

        // PUBLIC METHODS.
        async StartTimer(time) 
        {
            // END THE TIMER.
            this.EndTimer();

            // START THE TIMER.
            this.#timeLeftInTimer = time;

            // Update the timer display.
            this.#timerSpan.innerText = this.#timeLeftInTimer;
            this.#timerIntervalId = setInterval(() =>
            {
                // Update the timer display.
                this.#timeLeftInTimer -= 1;
                this.#timerSpan.innerText = this.#timeLeftInTimer;

                // Check if there is no time left.
                const timeIsLeft = this.#timeLeftInTimer <= 0;
                if (timeIsLeft)
                {
                    this.EndTimer()
                }      
            },
            1000);

            // Set the timer.
            const timeInMilliseconds = time * 1000;
            return new Promise((resolve) =>
            {
                this.#timerPromiseResolver = resolve;
                setTimeout(
                    resolve,
                    timeInMilliseconds);
            });
        }

        EndTimer()
        {
            const timerStarted = this.#timerIntervalId != null;
            if (timerStarted)
            {
                clearInterval(this.#timerIntervalId);
                this.#timerIntervalId = null;
                this.#timerPromiseResolver();
            }
        }

        constructor()
        {
            super();
        }
        
        connectedCallback()
        {
            // CREATE THE SHADOW DOM.
            const shadowRoot = this.attachShadow({ mode: "open" });

            // CREATE THE ELEMENTS IN THE ATTACK WINDOW.
            // Add the timer.
            this.#timerSpan = document.createElement("span");
            shadowRoot.appendChild(this.#timerSpan);
            this.#timerSpan.innerText = 0;
        }
    }
    customElements.define("game-timer", GameTimer);

    // THE ATTACK WINDOW CONTROL.
    class AttackWindow extends HTMLElement
    {
        // ELEMENTS.
        #phraseTextbox = null;
        #attackTimer = null;

        // PRIVATE MEMBERS.
        #gracePeriodInSeconds = 5;
        #timeToTypePhraseInSeconds = 10;
        #typingStartDateTime = null;
        #attackPromiseResolver = null;

        constructor()
        {
            super();
        }

        async Open()
        {
            // SHOW THE WINDOW.
            this.style.display = "block";

            // FOCUS ON THE TEXTBOX.
            this.#phraseTextbox.focus();

            // START THE GRACE PERIOD TIMER.
            this.#attackTimer.StartTimer(this.#gracePeriodInSeconds).then(() =>
            {
                this.#startTypingTimer();
            });
            
            // CREATE A PROMISE TO BE RESOLVED WHEN THE TIME HAS ENDED
            // OR A PHRASE WAS SUBMITTED.
            const attackPromise = new Promise((resolve) =>
                {
                    this.#attackPromiseResolver = resolve;
                });
            return attackPromise;
        }

        Close()
        {
            // RESET THE WINDOW.
            this.#gracePeriodInSeconds = 5;
            this.#timeToTypePhraseInSeconds = 10;
            this.#typingStartDateTime = null;
            this.#attackPromiseResolver = null;
            this.#phraseTextbox.value = "";
            
            // HIDE THE WINDOW.
            this.style.display = "none";
        }
        
        connectedCallback()
        {
            // CREATE THE SHADOW DOM.
            const shadowRoot = this.attachShadow({ mode: "open" });

            // SET THE INNER HTML.
            shadowRoot.innerHTML = `
<span>Type in a phrase.</span></br>
<game-timer id="GameTimer"></game-timer><input id="PhraseTextbox" type="text"></input>
            `;
            this.#attackTimer = shadowRoot.getElementById("GameTimer");
            this.#phraseTextbox = shadowRoot.getElementById("PhraseTextbox");

            // SET THE STYLE.
            const style = document.createElement("style");
            style.textContent = `
            #PhraseTextbox
            {
                margin: 4px;
            }`;
            shadowRoot.appendChild(style);

            // HANDLE THE USER STARTING TO TYPE.
            this.#phraseTextbox.addEventListener("input", () =>
            {
                const startedTyping = this.#typingStartDateTime != null;
                if (!startedTyping)
                {
                    // End the grace period timer.
                    this.#attackTimer.EndTimer();
                }
            });

            // HANDLE THE USER SUBMITTING THE PHRASE.
            this.#phraseTextbox.addEventListener("keydown", (event) =>
            // HANDLE THE USER SUBMITTING THE PHRASE.
            {
                if (event.key === "Enter")
                {
                    // End the typing timer.
                    this.#attackTimer.EndTimer();
                }
            });
            
            // HANDLE THE USER ENTERING CHARACTERS.
            this.#phraseTextbox.addEventListener("keypress", (event) =>
            {
                // Only allow alphabet characters.
                const characterIsAlpha = event.code !== `Key${event.key.toUpperCase()}`;
                const characterIsSpace = event.code = "Space";
                if (characterIsAlpha || characterIsSpace)
                {
                    event.preventDefault();
                }
            });
        }

        #startTypingTimer()
        {
            // Check if the timer was already started.
            const typingTimerStarted = this.#typingStartDateTime != null;
            if (!typingTimerStarted)
            {
                // Start the timer.
                this.#typingStartDateTime = new Date();
                this.#attackTimer.StartTimer(this.#timeToTypePhraseInSeconds).then(() =>
                {
                    // Submit the phrase when time runs out.
                    this.#submitPhrase();
                });
            }
        }

        #submitPhrase()
        {
            // Return the phrase and time to type the phrase.
            const typingEndDateTime = new Date();
            const typeTimeInSeconds = (typingEndDateTime - this.#typingStartDateTime) / 1000;
            this.#attackPromiseResolver(
                {
                    phrase: this.#phraseTextbox.value.trim(),
                    time: typeTimeInSeconds
                });
        }
    }
    customElements.define("attack-window", AttackWindow);

    // THE DEFENSE WINDOW CONTROL.
    class DefenseWindow extends HTMLElement
    {
        // ELEMENTS.
        #phraseDisplaySpan = null;
        #phraseTextbox = null;
        #defenseTimer = null;

        // PRIVATE MEMBERS.
        #gracePeriodInSeconds = 5;
        #timeToTypePhraseInSeconds = 10;
        #typingStartDateTime = null;
        #defensePromiseResolver = null;
        #currentChunk = null;

        constructor()
        {
            super();
        }

        async Open(phrase)
        {
            // FOCUS ON THE TEXTBOX.
            this.#phraseTextbox.focus();

            // HANDLE THE USER STARTING TO TYPE.
            this.#phraseTextbox.addEventListener("input", () =>
            {
                // End the grace period.
                const userStartedTyping = this.#typingStartDateTime != null;
                if (!userStartedTyping)
                {
                    this.#defenseTimer.EndTimer();
                }

                // Move to the next word if the chunk was entered correctly.
                const currentChunkText = this.#currentChunk.innerText;
                const inputText = this.#phraseTextbox.value;
                const wordIsCorrect = (currentChunkText == inputText)
                if (wordIsCorrect)
                {
                    this.#currentChunk.style.textDecoration = "none";
                    this.#phraseTextbox.value = "";
                    this.#currentChunk = this.#currentChunk.nextElementSibling;

                    // Check if the full phrase was entered.
                    const fullPhraseEntered = this.#currentChunk === null;
                    if (fullPhraseEntered)
                    {
                        // End the typing timer.
                        this.#defenseTimer.EndTimer();
                    }
                    else
                    {
                        this.#currentChunk.style.textDecoration = "underline";
                    }
                }
            });

            // ADD THE WORDS TO THE TYPE DISPLAY.
            const phraseChunks = phrase.split(" ");
            phraseChunks.forEach((chunk, index) =>
            {
                // CREATE THE SPAN FOR EACH CHUNK.
                const chunkSpan = document.createElement("span");
                this.#phraseDisplaySpan.insertAdjacentElement("beforeend", chunkSpan);
                chunkSpan.innerText = chunk;
                
                // Add a space to the end of the chunk if it is not the last chunk.
                const chunkIsLastInPhrase = (index == phraseChunks.length - 1);
                if (!chunkIsLastInPhrase)
                {
                    chunkSpan.innerText += " ";
                }
            });
            this.#currentChunk = this.#phraseDisplaySpan.children[0];
            this.#currentChunk.style.textDecoration = "underline";

            // SHOW THE WINDOW.
            this.style.display = "block";

            // START THE GRACE PERIOD TIMER.
            this.#defenseTimer.StartTimer(this.#gracePeriodInSeconds).then(() =>
            {
                this.#startTypingTimer();
            });
            
            // CREATE A PROMISE TO BE RESOLVED WHEN THE TIME HAS ENDED
            // OR THE PHRASE WAS COMPLETED.
            const defensePromise = new Promise((resolve) =>
                {
                    this.#defensePromiseResolver = resolve;
                });
            return defensePromise;
        }

        Close()
        {
            // RESET THE WINDOW.
            this.#gracePeriodInSeconds = 5;
            this.#timeToTypePhraseInSeconds = 10;
            this.#typingStartDateTime = null;
            this.#defensePromiseResolver = null;
            this.#phraseTextbox.value = "";
            this.#currentChunk = null;
            this.#phraseDisplaySpan.innerHTML = "";

            // HIDE THE WINDOW.
            this.style.display = "none";
        }
        
        connectedCallback()
        {
            // CREATE THE SHADOW DOM.
            const shadowRoot = this.attachShadow({ mode: "open" });

            // SET THE INNER HTML.
            shadowRoot.innerHTML = `
<span id="PhraseDisplaySpan"></span><br/>
<game-timer id="GameTimer"></game-timer><input id="PhraseTextbox" type="text"></input>
            `;
            this.#phraseDisplaySpan = shadowRoot.getElementById("PhraseDisplaySpan");
            this.#defenseTimer = shadowRoot.getElementById("GameTimer");
            this.#phraseTextbox = shadowRoot.getElementById("PhraseTextbox");

            // SET THE STYLE.
            const style = document.createElement("style");
            style.textContent = `
            #PhraseTextbox
            {
                margin: 4px;
            }`;
            shadowRoot.appendChild(style);
        }

        #startTypingTimer()
        {
            // Check if the typing timer was already started.
            const typingTimerStarted = this.#typingStartDateTime != null;
            if (!typingTimerStarted)
            {
                // Start the timer.
                this.#typingStartDateTime = new Date();
                this.#defenseTimer.StartTimer(this.#timeToTypePhraseInSeconds).then(() =>
                {
                    const typingEndDateTime = new Date();
                    const typeTimeInSeconds = (typingEndDateTime - this.#typingStartDateTime) / 1000;
                    this.#defensePromiseResolver({ time: typeTimeInSeconds });
                });
            }
        }
    }
    customElements.define("defense-window", DefenseWindow);
</script>

</html>